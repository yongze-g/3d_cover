# 对称像素检测算法设计与实现

## 1. 项目概述

本项目实现了一个PDF文件的对称像素检测算法，能够从横向和纵向两个方向扫描PDF转换后的图片，检测非白色像素的对称位置，并进行可视化输出。算法设计灵活，支持不同的扫描方向和有效位置数量要求。

## 2. 功能需求

### 2.1 核心功能
- 将PDF文件转换为图片
- 从横向（上下两端）逐行检测非白色像素
- 从纵向（左右两端）逐列检测非白色像素
- 对检测到的像素位置进行处理和优化
- 可视化输出检测结果

### 2.2 处理规则

#### 2.2.1 通用规则
- 对相邻像素取平均值，减少噪声干扰
- 计算上下/左右行/列的交集，只保留共同存在的位置
- 奇数个位置时，舍弃最中间的位置
- 替换同一侧距离显著小的相邻位置为平均值

#### 2.2.2 横向扫描特殊规则
- 有效位置数量要求：至少6个元素
- 保留所有处理后的有效位置

#### 2.2.3 纵向扫描特殊规则
- 有效位置数量要求：至少4个元素
- 仅保留最外侧一对的两个点

## 3. 算法设计

### 3.1 整体流程

```
┌─────────────────┐
│ 输入PDF文件     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ PDF转换为图片   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 横向扫描（上下）│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 纵向扫描（左右）│
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 可视化输出       │
└─────────────────┘
```

### 3.2 横向扫描算法

1. **从上下两端逐行扫描**：从第0行和最后一行开始，逐渐向中间靠拢
2. **检测非白色像素**：遍历每行的所有像素，记录非白色像素的X坐标
3. **处理相邻像素**：对相邻位置取平均值，减少噪声
4. **计算交集**：取上下行非白色像素位置的交集
5. **过滤有效位置**：只保留至少6个元素的位置列表
6. **处理有效位置**：
   - 奇数个位置时，舍弃中间位置
   - 替换同一侧距离显著小的相邻位置
7. **可视化标记**：在图片上标记对称位置和对称线

### 3.3 纵向扫描算法

1. **从左右两端逐列扫描**：从第0列和最后一列开始，逐渐向中间靠拢
2. **检测非白色像素**：遍历每列的所有像素，记录非白色像素的Y坐标
3. **处理相邻像素**：对相邻位置取平均值，减少噪声
4. **计算交集**：取左右列非白色像素位置的交集
5. **过滤有效位置**：只保留至少4个元素的位置列表
6. **处理有效位置**：
   - 奇数个位置时，舍弃中间位置
   - 替换同一侧距离显著小的相邻位置
   - 仅保留最外侧一对的两个点
7. **可视化标记**：在图片上标记对称位置和对称线

## 4. 实现细节

### 4.1 关键函数

#### 4.1.1 `is_white_pixel(pixel, tolerance=240)`
判断像素是否为白色，使用容差参数控制白色的定义

#### 4.1.2 `remove_adjacent_positions(positions, threshold=2)`
对相邻位置取平均值，threshold控制相邻像素的判断阈值

#### 4.1.3 `is_symmetric(positions1, positions2, tolerance=2)`
判断两个位置列表是否对称，允许一定的误差容差

#### 4.1.4 `find_symmetry_positions(img_path, direction="horizontal")`
核心检测函数，根据direction参数执行横向或纵向扫描

### 4.2 技术实现

- **PDF转换**：使用PyMuPDF库将PDF转换为图片
- **图片处理**：使用PIL库进行像素检测和可视化
- **算法核心**：纯Python实现，无需额外依赖
- **命令行界面**：支持命令行参数，方便使用

### 4.3 可视化实现

- **红色矩形**：标记上行/左列的有效位置
- **蓝色矩形**：标记下行/右列的有效位置
- **绿色线条**：连接上下/左右对称的位置
- **输出文件**：
  - 横向结果：`symmetry_visualization_horizontal.png`
  - 纵向结果：`symmetry_visualization_vertical.png`
  - 原始图片：`original.png`

## 5. 使用方法

### 5.1 命令行参数

```bash
python find_symmetry.py [pdf_path] [output_dir]
```

- `pdf_path`：可选，指定PDF文件路径，默认使用`frame_cv.pdf`
- `output_dir`：可选，指定输出目录，默认使用`output`

### 5.2 使用示例

#### 5.2.1 使用默认PDF和输出目录
```bash
python find_symmetry.py
```

#### 5.2.2 使用指定PDF和输出目录
```bash
python find_symmetry.py test3.pdf output_test3
```

## 6. 测试结果

### 6.1 frame_cv.pdf测试结果

| 扫描方向 | 对称位置数量 | 原始位置 | 处理后位置 | 最终结果 |
|---------|------------|---------|----------|--------|
| 横向 | 7个 | [36, 263, 788, 830, 872, 1397, 1624] | [36, 263, 788, 872, 1397, 1624] | 保留所有6个位置 |
| 纵向 | 6个 | [28, 36, 400, 405, 773, 782] | [32, 402, 778] | 仅保留最外侧一对：[32, 778] |

### 6.2 test3.pdf测试结果

| 扫描方向 | 对称位置数量 | 原始位置 | 处理后位置 | 最终结果 |
|---------|------------|---------|----------|--------|
| 横向 | 6个 | [20, 29, 553, 628, 1153, 1162] | [24, 553, 628, 1158] | 保留所有4个位置 |
| 纵向 | 4个 | [20, 29, 766, 774] | [24, 770] | 已经是最外侧一对，无需修改 |

## 7. 技术栈

- **编程语言**：Python 3.9+
- **PDF处理库**：PyMuPDF (fitz)
- **图片处理库**：PIL (Pillow)
- **可视化库**：PIL (Pillow)

## 8. 后续改进方向

1. **性能优化**：对于大尺寸图片，可以优化扫描算法，提高处理速度
2. **参数化配置**：支持通过配置文件或命令行参数调整各项阈值
3. **批量处理**：支持同时处理多个PDF文件
4. **更多扫描模式**：支持对角线扫描等更多扫描模式
5. **结果导出**：支持导出JSON格式的检测结果，方便后续处理
6. **交互式界面**：添加GUI界面，方便用户操作和查看结果
7. **自动识别**：自动识别图片的对称类型，选择合适的扫描方向
8. **容错处理**：增强对异常情况的处理能力，提高算法的鲁棒性

## 9. 结论

本算法设计灵活，实现了横向和纵向两个方向的对称像素检测，能够根据不同的扫描方向应用不同的处理规则。算法经过测试，在多个PDF文件上均能正确检测出对称位置，并进行可视化输出。后续可以根据实际需求进一步优化和扩展功能，提高算法的性能和适用范围。
